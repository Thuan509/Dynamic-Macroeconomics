%% File Info.
%{
    solve2.m
    -------
    This code solves the model using Backward Induction (BI).
%}

%% Solve class.
classdef solve2
    methods(Static)

        %% Solve the model using Backward Induction (BI)
        function sol = lc(par)          

            %% Structure array for model solution.
            sol = struct();
            
            %% Model parameters, grids, and functions.
            T = par.T; % Last period of life.
            tr = par.tr; % First year of retirement.

            beta = par.beta; % Discount factor.
            sigma = par.sigma; % CRRA.
            gamma = par.gamma; % Weight on leisure.
            nu = par.nu; % Frisch elasticity.

            alen = par.alen; % Grid size for assets.
            agrid = par.agrid; % Asset grid.

            ylen = par.ylen; % Grid size for income.
            ygrid = par.ygrid; % Income grid.
            pmat = par.pmat; % Transition matrix for income.

            r = par.r; % Real interest rate.
            kappa = par.kappa; % Pension replacement rate.

            Gmat = par.Gmat; % Age-dependent income process

            %% Backward Induction (BI) - Solve Value & Policy Functions
            fprintf('------------Solving the Life Cycle Model.------------\n\n')

            v1 = nan(alen, T, ylen); % Value function
            a1 = nan(alen, T, ylen); % Savings policy function
            c1 = nan(alen, T, ylen); % Consumption policy function
            n1 = nan(alen, T, ylen); % Labor supply function

            amat = repmat(agrid, 1, ylen);
            ymat = repmat(ygrid, alen, 1);

            for age = 1:T % Start in the last period and iterate forward
                if T - age + 1 == T % Last period of life
                    c1(:, T, :) = amat + kappa * ymat; % Consume everything
                    a1(:, T, :) = 0.0; % Save nothing
                    n1(:, T, :) = 0.0; % No labor in last period
                    v1(:, T, :) = model2.utility(c1(:,T,:),n1(:,T,:), par); % Terminal value function

                else % All other periods
                    for i = 1:ylen % Loop over income states
                        if T - age + 1 >= tr % Retirement period
                            %yt = kappa * ygrid(i); % Pension income
                            ev = v1(:, T - age + 2, i);
                            %nt = zeros(alen, 1); % No labor in retirement
                            
                        else % Working period
                            %yt = Gmat(age) * ygrid(i); % Labor income process
                            ev = squeeze(v1(:, T - age + 2, :)) * pmat(i, :)';
                        end

                        % Loop over assets
                        for p = 1:alen
                            for j = 1:alen
    
                                % Solve labor supply equation only in working period
                                if T - age + 1 < tr 
                                    ct = agrid(p) + (Gmat(age) * ygrid(i)) - (agrid(j)./(1+r));  
                                    ct(ct < 0.0) = 0.0; % No negative consumption

                                    fn = @(n) abs(((ct.^(-sigma))) + gamma * ((1 - n).^(1 / nu))); % Intratemporal condition of labor supply choice.
                                    nt  = fminbnd(fn, 0, 1); % Optimal labor supply
                                    nt = max(0, nt(p)); % Ensure non-negativity

                                    yt =  Gmat(age) * nt(age) * ygrid(i); % Labor income process

                                else
                                    nt = 0.0;
                                    yt = kappa * ygrid(i); % Pension income

                                    % Compute feasible consumption
                                    ct = agrid(p) + yt - (agrid(j)./(1+r));  
                                    ct(ct < 0.0) = 0.0; % No negative consumption
                                end
                            end
                        end

                        % Compute value function
                        vall = model2.utility(ct, nt, par) + beta * ev;
                        vall(ct <= 0.0) = -inf;
                        vall(nt <= 0.0) = -inf;

                        % Find optimal choice
                        [vmax, ind] = max(vall);

                        % Store results
                        v1(:, T - age + 1, i) = vmax;
                        c1(:, T - age + 1, i) = ct(ind);
                        a1(:, T - age + 1, i) = agrid(ind);
                        n1(:, T - age + 1, i) = nt(ind);
                    end
                end

                % Print progress
                if mod(T - age + 1, 5) == 0
                    fprintf('Age: %d.\n', T - age + 1)
                end
            end
            
            fprintf('------------Life Cycle Problem Solved.------------\n')

            %% Store results
            sol.c = c1; % Consumption policy function
            sol.a = a1; % Saving policy function
            sol.v = v1; % Value function
            sol.n = n1; % Labor supply function
        end
    end
end
